# 클로저 
# 함수안의 함수를 결과로 반환할 때(콜백함수, 데코레이터 함수 사용)

class Add:
    def __init__(self,n1):
        self.n1=n1 # Add 객체를 만들 때 숫자 하나를 받아서 n1에 저장한다

    def add(self,n):
        return self.n1+n
    
a=Add(10) # self.n1 = 10
print(a.add(10))
a2=Add(20)
print(a2.add(10))
print('-------------------------------------')

#add 바깥 함수에 안에 wrapper라는 함수가 안에 있음 (inner function)
#내부 함수가 바깥 함수의 n1 을 기억하고 사용할 수 있는 구조로 되어있음 (클로저 특징)
def add(n1):
    def wrapper(n) :
        return n1+n
    return wrapper

a1=add(10) #n1=10 wrapper 가 기억하고 a1 은 함수가 됨
print(a1(10))
# a1=add(10) => n1=10 저장 -> wrapper 함수 반환 -> a1 이 wrapper에 들어가 함수가 됨
# print(a1(10)) -> print(wrapper(10)) -> n1(기억해놓은 10)+10 -> 20
a2=add(20)
print(a2(10))

#데코레이터
#함수에 @ 기능을 붙인다
#매개변수가 없는 함수만 감쌀 수 있다.

#클로저 
def trace(func):
    def wrapper():
        print('시작')
        func()
        print('끝')
    return wrapper # 함수반환

@trace # hi = trace(hi)
def hi():
    print('hi')

@trace # hello = trace(hello)
def hello():
    print('hello')

t1=trace(hi) # t1 = wrapper / hi(func)를 기억하고있음 (외부변수)
t1() # 함수 호출 wrapper()
t2=trace(hello)
t2()


def trace(func): # p.160,162
    def wrapper(*args,**kwargs):
        result=func(*args,**kwargs)
        print(args,kwargs,result)
        return result
    return wrapper

@trace
def big(*args): #개수가 정해져있지 않은 가변인자 # 2. wrapper(10,20) 실행->result=max(10,20)->20
    return max (args) # 가변인자중 가장 큰값을 반환

@trace
def min1(**kwargs):
    return min(kwargs.values())

print(big(10,20)) #1. 데코레이터 호출되면 wrapper 실행됨
print(min1(x=20,y=30,z=40)) # kwargs dict 구조로 입력
